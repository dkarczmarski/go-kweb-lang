// Code generated by MockGen. DO NOT EDIT.
// Source: gitseek.go
//
// Generated by this command:
//
//	mockgen -typed -source=gitseek.go -destination=./internal/mocks/mocks.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	git "go-kweb-lang/git"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockGitRepo is a mock of GitRepo interface.
type MockGitRepo struct {
	ctrl     *gomock.Controller
	recorder *MockGitRepoMockRecorder
	isgomock struct{}
}

// MockGitRepoMockRecorder is the mock recorder for MockGitRepo.
type MockGitRepoMockRecorder struct {
	mock *MockGitRepo
}

// NewMockGitRepo creates a new mock instance.
func NewMockGitRepo(ctrl *gomock.Controller) *MockGitRepo {
	mock := &MockGitRepo{ctrl: ctrl}
	mock.recorder = &MockGitRepoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGitRepo) EXPECT() *MockGitRepoMockRecorder {
	return m.recorder
}

// FileExists mocks base method.
func (m *MockGitRepo) FileExists(path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FileExists", path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FileExists indicates an expected call of FileExists.
func (mr *MockGitRepoMockRecorder) FileExists(path any) *MockGitRepoFileExistsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FileExists", reflect.TypeOf((*MockGitRepo)(nil).FileExists), path)
	return &MockGitRepoFileExistsCall{Call: call}
}

// MockGitRepoFileExistsCall wrap *gomock.Call
type MockGitRepoFileExistsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitRepoFileExistsCall) Return(arg0 bool, arg1 error) *MockGitRepoFileExistsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitRepoFileExistsCall) Do(f func(string) (bool, error)) *MockGitRepoFileExistsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitRepoFileExistsCall) DoAndReturn(f func(string) (bool, error)) *MockGitRepoFileExistsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindFileCommitsAfter mocks base method.
func (m *MockGitRepo) FindFileCommitsAfter(ctx context.Context, path, commitIDFrom string) ([]git.CommitInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindFileCommitsAfter", ctx, path, commitIDFrom)
	ret0, _ := ret[0].([]git.CommitInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindFileCommitsAfter indicates an expected call of FindFileCommitsAfter.
func (mr *MockGitRepoMockRecorder) FindFileCommitsAfter(ctx, path, commitIDFrom any) *MockGitRepoFindFileCommitsAfterCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindFileCommitsAfter", reflect.TypeOf((*MockGitRepo)(nil).FindFileCommitsAfter), ctx, path, commitIDFrom)
	return &MockGitRepoFindFileCommitsAfterCall{Call: call}
}

// MockGitRepoFindFileCommitsAfterCall wrap *gomock.Call
type MockGitRepoFindFileCommitsAfterCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitRepoFindFileCommitsAfterCall) Return(arg0 []git.CommitInfo, arg1 error) *MockGitRepoFindFileCommitsAfterCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitRepoFindFileCommitsAfterCall) Do(f func(context.Context, string, string) ([]git.CommitInfo, error)) *MockGitRepoFindFileCommitsAfterCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitRepoFindFileCommitsAfterCall) DoAndReturn(f func(context.Context, string, string) ([]git.CommitInfo, error)) *MockGitRepoFindFileCommitsAfterCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindFileLastCommit mocks base method.
func (m *MockGitRepo) FindFileLastCommit(ctx context.Context, path string) (git.CommitInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindFileLastCommit", ctx, path)
	ret0, _ := ret[0].(git.CommitInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindFileLastCommit indicates an expected call of FindFileLastCommit.
func (mr *MockGitRepoMockRecorder) FindFileLastCommit(ctx, path any) *MockGitRepoFindFileLastCommitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindFileLastCommit", reflect.TypeOf((*MockGitRepo)(nil).FindFileLastCommit), ctx, path)
	return &MockGitRepoFindFileLastCommitCall{Call: call}
}

// MockGitRepoFindFileLastCommitCall wrap *gomock.Call
type MockGitRepoFindFileLastCommitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitRepoFindFileLastCommitCall) Return(arg0 git.CommitInfo, arg1 error) *MockGitRepoFindFileLastCommitCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitRepoFindFileLastCommitCall) Do(f func(context.Context, string) (git.CommitInfo, error)) *MockGitRepoFindFileLastCommitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitRepoFindFileLastCommitCall) DoAndReturn(f func(context.Context, string) (git.CommitInfo, error)) *MockGitRepoFindFileLastCommitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListFiles mocks base method.
func (m *MockGitRepo) ListFiles(path string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListFiles", path)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListFiles indicates an expected call of ListFiles.
func (mr *MockGitRepoMockRecorder) ListFiles(path any) *MockGitRepoListFilesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListFiles", reflect.TypeOf((*MockGitRepo)(nil).ListFiles), path)
	return &MockGitRepoListFilesCall{Call: call}
}

// MockGitRepoListFilesCall wrap *gomock.Call
type MockGitRepoListFilesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitRepoListFilesCall) Return(arg0 []string, arg1 error) *MockGitRepoListFilesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitRepoListFilesCall) Do(f func(string) ([]string, error)) *MockGitRepoListFilesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitRepoListFilesCall) DoAndReturn(f func(string) ([]string, error)) *MockGitRepoListFilesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockGitRepoHist is a mock of GitRepoHist interface.
type MockGitRepoHist struct {
	ctrl     *gomock.Controller
	recorder *MockGitRepoHistMockRecorder
	isgomock struct{}
}

// MockGitRepoHistMockRecorder is the mock recorder for MockGitRepoHist.
type MockGitRepoHistMockRecorder struct {
	mock *MockGitRepoHist
}

// NewMockGitRepoHist creates a new mock instance.
func NewMockGitRepoHist(ctrl *gomock.Controller) *MockGitRepoHist {
	mock := &MockGitRepoHist{ctrl: ctrl}
	mock.recorder = &MockGitRepoHistMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGitRepoHist) EXPECT() *MockGitRepoHistMockRecorder {
	return m.recorder
}

// FindForkCommit mocks base method.
func (m *MockGitRepoHist) FindForkCommit(ctx context.Context, commitID string) (*git.CommitInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindForkCommit", ctx, commitID)
	ret0, _ := ret[0].(*git.CommitInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindForkCommit indicates an expected call of FindForkCommit.
func (mr *MockGitRepoHistMockRecorder) FindForkCommit(ctx, commitID any) *MockGitRepoHistFindForkCommitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindForkCommit", reflect.TypeOf((*MockGitRepoHist)(nil).FindForkCommit), ctx, commitID)
	return &MockGitRepoHistFindForkCommitCall{Call: call}
}

// MockGitRepoHistFindForkCommitCall wrap *gomock.Call
type MockGitRepoHistFindForkCommitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitRepoHistFindForkCommitCall) Return(arg0 *git.CommitInfo, arg1 error) *MockGitRepoHistFindForkCommitCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitRepoHistFindForkCommitCall) Do(f func(context.Context, string) (*git.CommitInfo, error)) *MockGitRepoHistFindForkCommitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitRepoHistFindForkCommitCall) DoAndReturn(f func(context.Context, string) (*git.CommitInfo, error)) *MockGitRepoHistFindForkCommitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindMergeCommit mocks base method.
func (m *MockGitRepoHist) FindMergeCommit(ctx context.Context, commitID string) (*git.CommitInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindMergeCommit", ctx, commitID)
	ret0, _ := ret[0].(*git.CommitInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindMergeCommit indicates an expected call of FindMergeCommit.
func (mr *MockGitRepoHistMockRecorder) FindMergeCommit(ctx, commitID any) *MockGitRepoHistFindMergeCommitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindMergeCommit", reflect.TypeOf((*MockGitRepoHist)(nil).FindMergeCommit), ctx, commitID)
	return &MockGitRepoHistFindMergeCommitCall{Call: call}
}

// MockGitRepoHistFindMergeCommitCall wrap *gomock.Call
type MockGitRepoHistFindMergeCommitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitRepoHistFindMergeCommitCall) Return(arg0 *git.CommitInfo, arg1 error) *MockGitRepoHistFindMergeCommitCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitRepoHistFindMergeCommitCall) Do(f func(context.Context, string) (*git.CommitInfo, error)) *MockGitRepoHistFindMergeCommitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitRepoHistFindMergeCommitCall) DoAndReturn(f func(context.Context, string) (*git.CommitInfo, error)) *MockGitRepoHistFindMergeCommitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockCacheStore is a mock of CacheStore interface.
type MockCacheStore struct {
	ctrl     *gomock.Controller
	recorder *MockCacheStoreMockRecorder
	isgomock struct{}
}

// MockCacheStoreMockRecorder is the mock recorder for MockCacheStore.
type MockCacheStoreMockRecorder struct {
	mock *MockCacheStore
}

// NewMockCacheStore creates a new mock instance.
func NewMockCacheStore(ctrl *gomock.Controller) *MockCacheStore {
	mock := &MockCacheStore{ctrl: ctrl}
	mock.recorder = &MockCacheStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCacheStore) EXPECT() *MockCacheStoreMockRecorder {
	return m.recorder
}

// Delete mocks base method.
func (m *MockCacheStore) Delete(bucket, key string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", bucket, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockCacheStoreMockRecorder) Delete(bucket, key any) *MockCacheStoreDeleteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockCacheStore)(nil).Delete), bucket, key)
	return &MockCacheStoreDeleteCall{Call: call}
}

// MockCacheStoreDeleteCall wrap *gomock.Call
type MockCacheStoreDeleteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCacheStoreDeleteCall) Return(arg0 error) *MockCacheStoreDeleteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCacheStoreDeleteCall) Do(f func(string, string) error) *MockCacheStoreDeleteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCacheStoreDeleteCall) DoAndReturn(f func(string, string) error) *MockCacheStoreDeleteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListBuckets mocks base method.
func (m *MockCacheStore) ListBuckets(bucketPth string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListBuckets", bucketPth)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListBuckets indicates an expected call of ListBuckets.
func (mr *MockCacheStoreMockRecorder) ListBuckets(bucketPth any) *MockCacheStoreListBucketsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListBuckets", reflect.TypeOf((*MockCacheStore)(nil).ListBuckets), bucketPth)
	return &MockCacheStoreListBucketsCall{Call: call}
}

// MockCacheStoreListBucketsCall wrap *gomock.Call
type MockCacheStoreListBucketsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCacheStoreListBucketsCall) Return(arg0 []string, arg1 error) *MockCacheStoreListBucketsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCacheStoreListBucketsCall) Do(f func(string) ([]string, error)) *MockCacheStoreListBucketsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCacheStoreListBucketsCall) DoAndReturn(f func(string) ([]string, error)) *MockCacheStoreListBucketsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Read mocks base method.
func (m *MockCacheStore) Read(bucket, key string, buff any) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Read", bucket, key, buff)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Read indicates an expected call of Read.
func (mr *MockCacheStoreMockRecorder) Read(bucket, key, buff any) *MockCacheStoreReadCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockCacheStore)(nil).Read), bucket, key, buff)
	return &MockCacheStoreReadCall{Call: call}
}

// MockCacheStoreReadCall wrap *gomock.Call
type MockCacheStoreReadCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCacheStoreReadCall) Return(arg0 bool, arg1 error) *MockCacheStoreReadCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCacheStoreReadCall) Do(f func(string, string, any) (bool, error)) *MockCacheStoreReadCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCacheStoreReadCall) DoAndReturn(f func(string, string, any) (bool, error)) *MockCacheStoreReadCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Write mocks base method.
func (m *MockCacheStore) Write(bucket, key string, data any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Write", bucket, key, data)
	ret0, _ := ret[0].(error)
	return ret0
}

// Write indicates an expected call of Write.
func (mr *MockCacheStoreMockRecorder) Write(bucket, key, data any) *MockCacheStoreWriteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockCacheStore)(nil).Write), bucket, key, data)
	return &MockCacheStoreWriteCall{Call: call}
}

// MockCacheStoreWriteCall wrap *gomock.Call
type MockCacheStoreWriteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCacheStoreWriteCall) Return(arg0 error) *MockCacheStoreWriteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCacheStoreWriteCall) Do(f func(string, string, any) error) *MockCacheStoreWriteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCacheStoreWriteCall) DoAndReturn(f func(string, string, any) error) *MockCacheStoreWriteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
