// Code generated by MockGen. DO NOT EDIT.
// Source: githist.go
//
// Generated by this command:
//
//	mockgen -typed -source=githist.go -destination=./internal/mocks/mocks.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	git "go-kweb-lang/git"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockGitRepo is a mock of GitRepo interface.
type MockGitRepo struct {
	ctrl     *gomock.Controller
	recorder *MockGitRepoMockRecorder
	isgomock struct{}
}

// MockGitRepoMockRecorder is the mock recorder for MockGitRepo.
type MockGitRepoMockRecorder struct {
	mock *MockGitRepo
}

// NewMockGitRepo creates a new mock instance.
func NewMockGitRepo(ctrl *gomock.Controller) *MockGitRepo {
	mock := &MockGitRepo{ctrl: ctrl}
	mock.recorder = &MockGitRepoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGitRepo) EXPECT() *MockGitRepoMockRecorder {
	return m.recorder
}

// Fetch mocks base method.
func (m *MockGitRepo) Fetch(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Fetch", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Fetch indicates an expected call of Fetch.
func (mr *MockGitRepoMockRecorder) Fetch(ctx any) *MockGitRepoFetchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fetch", reflect.TypeOf((*MockGitRepo)(nil).Fetch), ctx)
	return &MockGitRepoFetchCall{Call: call}
}

// MockGitRepoFetchCall wrap *gomock.Call
type MockGitRepoFetchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitRepoFetchCall) Return(arg0 error) *MockGitRepoFetchCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitRepoFetchCall) Do(f func(context.Context) error) *MockGitRepoFetchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitRepoFetchCall) DoAndReturn(f func(context.Context) error) *MockGitRepoFetchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListAncestorCommits mocks base method.
func (m *MockGitRepo) ListAncestorCommits(ctx context.Context, commitID string) ([]git.CommitInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListAncestorCommits", ctx, commitID)
	ret0, _ := ret[0].([]git.CommitInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListAncestorCommits indicates an expected call of ListAncestorCommits.
func (mr *MockGitRepoMockRecorder) ListAncestorCommits(ctx, commitID any) *MockGitRepoListAncestorCommitsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAncestorCommits", reflect.TypeOf((*MockGitRepo)(nil).ListAncestorCommits), ctx, commitID)
	return &MockGitRepoListAncestorCommitsCall{Call: call}
}

// MockGitRepoListAncestorCommitsCall wrap *gomock.Call
type MockGitRepoListAncestorCommitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitRepoListAncestorCommitsCall) Return(arg0 []git.CommitInfo, arg1 error) *MockGitRepoListAncestorCommitsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitRepoListAncestorCommitsCall) Do(f func(context.Context, string) ([]git.CommitInfo, error)) *MockGitRepoListAncestorCommitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitRepoListAncestorCommitsCall) DoAndReturn(f func(context.Context, string) ([]git.CommitInfo, error)) *MockGitRepoListAncestorCommitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListCommitParents mocks base method.
func (m *MockGitRepo) ListCommitParents(ctx context.Context, commitID string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListCommitParents", ctx, commitID)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListCommitParents indicates an expected call of ListCommitParents.
func (mr *MockGitRepoMockRecorder) ListCommitParents(ctx, commitID any) *MockGitRepoListCommitParentsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCommitParents", reflect.TypeOf((*MockGitRepo)(nil).ListCommitParents), ctx, commitID)
	return &MockGitRepoListCommitParentsCall{Call: call}
}

// MockGitRepoListCommitParentsCall wrap *gomock.Call
type MockGitRepoListCommitParentsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitRepoListCommitParentsCall) Return(arg0 []string, arg1 error) *MockGitRepoListCommitParentsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitRepoListCommitParentsCall) Do(f func(context.Context, string) ([]string, error)) *MockGitRepoListCommitParentsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitRepoListCommitParentsCall) DoAndReturn(f func(context.Context, string) ([]string, error)) *MockGitRepoListCommitParentsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListFilesBetweenCommits mocks base method.
func (m *MockGitRepo) ListFilesBetweenCommits(ctx context.Context, forkCommitID, branchLastCommitID string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListFilesBetweenCommits", ctx, forkCommitID, branchLastCommitID)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListFilesBetweenCommits indicates an expected call of ListFilesBetweenCommits.
func (mr *MockGitRepoMockRecorder) ListFilesBetweenCommits(ctx, forkCommitID, branchLastCommitID any) *MockGitRepoListFilesBetweenCommitsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListFilesBetweenCommits", reflect.TypeOf((*MockGitRepo)(nil).ListFilesBetweenCommits), ctx, forkCommitID, branchLastCommitID)
	return &MockGitRepoListFilesBetweenCommitsCall{Call: call}
}

// MockGitRepoListFilesBetweenCommitsCall wrap *gomock.Call
type MockGitRepoListFilesBetweenCommitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitRepoListFilesBetweenCommitsCall) Return(arg0 []string, arg1 error) *MockGitRepoListFilesBetweenCommitsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitRepoListFilesBetweenCommitsCall) Do(f func(context.Context, string, string) ([]string, error)) *MockGitRepoListFilesBetweenCommitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitRepoListFilesBetweenCommitsCall) DoAndReturn(f func(context.Context, string, string) ([]string, error)) *MockGitRepoListFilesBetweenCommitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListFilesInCommit mocks base method.
func (m *MockGitRepo) ListFilesInCommit(ctx context.Context, commitID string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListFilesInCommit", ctx, commitID)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListFilesInCommit indicates an expected call of ListFilesInCommit.
func (mr *MockGitRepoMockRecorder) ListFilesInCommit(ctx, commitID any) *MockGitRepoListFilesInCommitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListFilesInCommit", reflect.TypeOf((*MockGitRepo)(nil).ListFilesInCommit), ctx, commitID)
	return &MockGitRepoListFilesInCommitCall{Call: call}
}

// MockGitRepoListFilesInCommitCall wrap *gomock.Call
type MockGitRepoListFilesInCommitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitRepoListFilesInCommitCall) Return(arg0 []string, arg1 error) *MockGitRepoListFilesInCommitCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitRepoListFilesInCommitCall) Do(f func(context.Context, string) ([]string, error)) *MockGitRepoListFilesInCommitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitRepoListFilesInCommitCall) DoAndReturn(f func(context.Context, string) ([]string, error)) *MockGitRepoListFilesInCommitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListFreshCommits mocks base method.
func (m *MockGitRepo) ListFreshCommits(ctx context.Context) ([]git.CommitInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListFreshCommits", ctx)
	ret0, _ := ret[0].([]git.CommitInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListFreshCommits indicates an expected call of ListFreshCommits.
func (mr *MockGitRepoMockRecorder) ListFreshCommits(ctx any) *MockGitRepoListFreshCommitsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListFreshCommits", reflect.TypeOf((*MockGitRepo)(nil).ListFreshCommits), ctx)
	return &MockGitRepoListFreshCommitsCall{Call: call}
}

// MockGitRepoListFreshCommitsCall wrap *gomock.Call
type MockGitRepoListFreshCommitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitRepoListFreshCommitsCall) Return(arg0 []git.CommitInfo, arg1 error) *MockGitRepoListFreshCommitsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitRepoListFreshCommitsCall) Do(f func(context.Context) ([]git.CommitInfo, error)) *MockGitRepoListFreshCommitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitRepoListFreshCommitsCall) DoAndReturn(f func(context.Context) ([]git.CommitInfo, error)) *MockGitRepoListFreshCommitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListMainBranchCommits mocks base method.
func (m *MockGitRepo) ListMainBranchCommits(ctx context.Context) ([]git.CommitInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListMainBranchCommits", ctx)
	ret0, _ := ret[0].([]git.CommitInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListMainBranchCommits indicates an expected call of ListMainBranchCommits.
func (mr *MockGitRepoMockRecorder) ListMainBranchCommits(ctx any) *MockGitRepoListMainBranchCommitsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListMainBranchCommits", reflect.TypeOf((*MockGitRepo)(nil).ListMainBranchCommits), ctx)
	return &MockGitRepoListMainBranchCommitsCall{Call: call}
}

// MockGitRepoListMainBranchCommitsCall wrap *gomock.Call
type MockGitRepoListMainBranchCommitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitRepoListMainBranchCommitsCall) Return(arg0 []git.CommitInfo, arg1 error) *MockGitRepoListMainBranchCommitsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitRepoListMainBranchCommitsCall) Do(f func(context.Context) ([]git.CommitInfo, error)) *MockGitRepoListMainBranchCommitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitRepoListMainBranchCommitsCall) DoAndReturn(f func(context.Context) ([]git.CommitInfo, error)) *MockGitRepoListMainBranchCommitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListMergePoints mocks base method.
func (m *MockGitRepo) ListMergePoints(ctx context.Context, commitID string) ([]git.CommitInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListMergePoints", ctx, commitID)
	ret0, _ := ret[0].([]git.CommitInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListMergePoints indicates an expected call of ListMergePoints.
func (mr *MockGitRepoMockRecorder) ListMergePoints(ctx, commitID any) *MockGitRepoListMergePointsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListMergePoints", reflect.TypeOf((*MockGitRepo)(nil).ListMergePoints), ctx, commitID)
	return &MockGitRepoListMergePointsCall{Call: call}
}

// MockGitRepoListMergePointsCall wrap *gomock.Call
type MockGitRepoListMergePointsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitRepoListMergePointsCall) Return(arg0 []git.CommitInfo, arg1 error) *MockGitRepoListMergePointsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitRepoListMergePointsCall) Do(f func(context.Context, string) ([]git.CommitInfo, error)) *MockGitRepoListMergePointsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitRepoListMergePointsCall) DoAndReturn(f func(context.Context, string) ([]git.CommitInfo, error)) *MockGitRepoListMergePointsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Pull mocks base method.
func (m *MockGitRepo) Pull(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Pull", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Pull indicates an expected call of Pull.
func (mr *MockGitRepoMockRecorder) Pull(ctx any) *MockGitRepoPullCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pull", reflect.TypeOf((*MockGitRepo)(nil).Pull), ctx)
	return &MockGitRepoPullCall{Call: call}
}

// MockGitRepoPullCall wrap *gomock.Call
type MockGitRepoPullCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockGitRepoPullCall) Return(arg0 error) *MockGitRepoPullCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockGitRepoPullCall) Do(f func(context.Context) error) *MockGitRepoPullCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockGitRepoPullCall) DoAndReturn(f func(context.Context) error) *MockGitRepoPullCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockCacheStore is a mock of CacheStore interface.
type MockCacheStore struct {
	ctrl     *gomock.Controller
	recorder *MockCacheStoreMockRecorder
	isgomock struct{}
}

// MockCacheStoreMockRecorder is the mock recorder for MockCacheStore.
type MockCacheStoreMockRecorder struct {
	mock *MockCacheStore
}

// NewMockCacheStore creates a new mock instance.
func NewMockCacheStore(ctrl *gomock.Controller) *MockCacheStore {
	mock := &MockCacheStore{ctrl: ctrl}
	mock.recorder = &MockCacheStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCacheStore) EXPECT() *MockCacheStoreMockRecorder {
	return m.recorder
}

// Delete mocks base method.
func (m *MockCacheStore) Delete(bucket, key string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", bucket, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockCacheStoreMockRecorder) Delete(bucket, key any) *MockCacheStoreDeleteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockCacheStore)(nil).Delete), bucket, key)
	return &MockCacheStoreDeleteCall{Call: call}
}

// MockCacheStoreDeleteCall wrap *gomock.Call
type MockCacheStoreDeleteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCacheStoreDeleteCall) Return(arg0 error) *MockCacheStoreDeleteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCacheStoreDeleteCall) Do(f func(string, string) error) *MockCacheStoreDeleteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCacheStoreDeleteCall) DoAndReturn(f func(string, string) error) *MockCacheStoreDeleteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Read mocks base method.
func (m *MockCacheStore) Read(bucket, key string, buff any) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Read", bucket, key, buff)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Read indicates an expected call of Read.
func (mr *MockCacheStoreMockRecorder) Read(bucket, key, buff any) *MockCacheStoreReadCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockCacheStore)(nil).Read), bucket, key, buff)
	return &MockCacheStoreReadCall{Call: call}
}

// MockCacheStoreReadCall wrap *gomock.Call
type MockCacheStoreReadCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCacheStoreReadCall) Return(arg0 bool, arg1 error) *MockCacheStoreReadCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCacheStoreReadCall) Do(f func(string, string, any) (bool, error)) *MockCacheStoreReadCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCacheStoreReadCall) DoAndReturn(f func(string, string, any) (bool, error)) *MockCacheStoreReadCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Write mocks base method.
func (m *MockCacheStore) Write(bucket, key string, data any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Write", bucket, key, data)
	ret0, _ := ret[0].(error)
	return ret0
}

// Write indicates an expected call of Write.
func (mr *MockCacheStoreMockRecorder) Write(bucket, key, data any) *MockCacheStoreWriteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockCacheStore)(nil).Write), bucket, key, data)
	return &MockCacheStoreWriteCall{Call: call}
}

// MockCacheStoreWriteCall wrap *gomock.Call
type MockCacheStoreWriteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCacheStoreWriteCall) Return(arg0 error) *MockCacheStoreWriteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCacheStoreWriteCall) Do(f func(string, string, any) error) *MockCacheStoreWriteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCacheStoreWriteCall) DoAndReturn(f func(string, string, any) error) *MockCacheStoreWriteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockInvalidator is a mock of Invalidator interface.
type MockInvalidator struct {
	ctrl     *gomock.Controller
	recorder *MockInvalidatorMockRecorder
	isgomock struct{}
}

// MockInvalidatorMockRecorder is the mock recorder for MockInvalidator.
type MockInvalidatorMockRecorder struct {
	mock *MockInvalidator
}

// NewMockInvalidator creates a new mock instance.
func NewMockInvalidator(ctrl *gomock.Controller) *MockInvalidator {
	mock := &MockInvalidator{ctrl: ctrl}
	mock.recorder = &MockInvalidatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInvalidator) EXPECT() *MockInvalidatorMockRecorder {
	return m.recorder
}

// InvalidateFile mocks base method.
func (m *MockInvalidator) InvalidateFile(path string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InvalidateFile", path)
	ret0, _ := ret[0].(error)
	return ret0
}

// InvalidateFile indicates an expected call of InvalidateFile.
func (mr *MockInvalidatorMockRecorder) InvalidateFile(path any) *MockInvalidatorInvalidateFileCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InvalidateFile", reflect.TypeOf((*MockInvalidator)(nil).InvalidateFile), path)
	return &MockInvalidatorInvalidateFileCall{Call: call}
}

// MockInvalidatorInvalidateFileCall wrap *gomock.Call
type MockInvalidatorInvalidateFileCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockInvalidatorInvalidateFileCall) Return(arg0 error) *MockInvalidatorInvalidateFileCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockInvalidatorInvalidateFileCall) Do(f func(string) error) *MockInvalidatorInvalidateFileCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockInvalidatorInvalidateFileCall) DoAndReturn(f func(string) error) *MockInvalidatorInvalidateFileCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
