// Code generated by MockGen. DO NOT EDIT.
// Source: git.go
//
// Generated by this command:
//
//	mockgen -typed -source=git.go -destination=../mocks/mock_git.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	git "go-kweb-lang/git"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockRepo is a mock of Repo interface.
type MockRepo struct {
	ctrl     *gomock.Controller
	recorder *MockRepoMockRecorder
	isgomock struct{}
}

// MockRepoMockRecorder is the mock recorder for MockRepo.
type MockRepoMockRecorder struct {
	mock *MockRepo
}

// NewMockRepo creates a new mock instance.
func NewMockRepo(ctrl *gomock.Controller) *MockRepo {
	mock := &MockRepo{ctrl: ctrl}
	mock.recorder = &MockRepoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepo) EXPECT() *MockRepoMockRecorder {
	return m.recorder
}

// CommitFiles mocks base method.
func (m *MockRepo) CommitFiles(commitId string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CommitFiles", commitId)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CommitFiles indicates an expected call of CommitFiles.
func (mr *MockRepoMockRecorder) CommitFiles(commitId any) *MockRepoCommitFilesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CommitFiles", reflect.TypeOf((*MockRepo)(nil).CommitFiles), commitId)
	return &MockRepoCommitFilesCall{Call: call}
}

// MockRepoCommitFilesCall wrap *gomock.Call
type MockRepoCommitFilesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepoCommitFilesCall) Return(arg0 []string, arg1 error) *MockRepoCommitFilesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepoCommitFilesCall) Do(f func(string) ([]string, error)) *MockRepoCommitFilesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepoCommitFilesCall) DoAndReturn(f func(string) ([]string, error)) *MockRepoCommitFilesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Fetch mocks base method.
func (m *MockRepo) Fetch() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Fetch")
	ret0, _ := ret[0].(error)
	return ret0
}

// Fetch indicates an expected call of Fetch.
func (mr *MockRepoMockRecorder) Fetch() *MockRepoFetchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fetch", reflect.TypeOf((*MockRepo)(nil).Fetch))
	return &MockRepoFetchCall{Call: call}
}

// MockRepoFetchCall wrap *gomock.Call
type MockRepoFetchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepoFetchCall) Return(arg0 error) *MockRepoFetchCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepoFetchCall) Do(f func() error) *MockRepoFetchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepoFetchCall) DoAndReturn(f func() error) *MockRepoFetchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FileExists mocks base method.
func (m *MockRepo) FileExists(path string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FileExists", path)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FileExists indicates an expected call of FileExists.
func (mr *MockRepoMockRecorder) FileExists(path any) *MockRepoFileExistsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FileExists", reflect.TypeOf((*MockRepo)(nil).FileExists), path)
	return &MockRepoFileExistsCall{Call: call}
}

// MockRepoFileExistsCall wrap *gomock.Call
type MockRepoFileExistsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepoFileExistsCall) Return(arg0 bool, arg1 error) *MockRepoFileExistsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepoFileExistsCall) Do(f func(string) (bool, error)) *MockRepoFileExistsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepoFileExistsCall) DoAndReturn(f func(string) (bool, error)) *MockRepoFileExistsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindFileCommitsAfter mocks base method.
func (m *MockRepo) FindFileCommitsAfter(path, commitIdFrom string) ([]git.CommitInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindFileCommitsAfter", path, commitIdFrom)
	ret0, _ := ret[0].([]git.CommitInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindFileCommitsAfter indicates an expected call of FindFileCommitsAfter.
func (mr *MockRepoMockRecorder) FindFileCommitsAfter(path, commitIdFrom any) *MockRepoFindFileCommitsAfterCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindFileCommitsAfter", reflect.TypeOf((*MockRepo)(nil).FindFileCommitsAfter), path, commitIdFrom)
	return &MockRepoFindFileCommitsAfterCall{Call: call}
}

// MockRepoFindFileCommitsAfterCall wrap *gomock.Call
type MockRepoFindFileCommitsAfterCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepoFindFileCommitsAfterCall) Return(arg0 []git.CommitInfo, arg1 error) *MockRepoFindFileCommitsAfterCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepoFindFileCommitsAfterCall) Do(f func(string, string) ([]git.CommitInfo, error)) *MockRepoFindFileCommitsAfterCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepoFindFileCommitsAfterCall) DoAndReturn(f func(string, string) ([]git.CommitInfo, error)) *MockRepoFindFileCommitsAfterCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindFileLastCommit mocks base method.
func (m *MockRepo) FindFileLastCommit(path string) (git.CommitInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindFileLastCommit", path)
	ret0, _ := ret[0].(git.CommitInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindFileLastCommit indicates an expected call of FindFileLastCommit.
func (mr *MockRepoMockRecorder) FindFileLastCommit(path any) *MockRepoFindFileLastCommitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindFileLastCommit", reflect.TypeOf((*MockRepo)(nil).FindFileLastCommit), path)
	return &MockRepoFindFileLastCommitCall{Call: call}
}

// MockRepoFindFileLastCommitCall wrap *gomock.Call
type MockRepoFindFileLastCommitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepoFindFileLastCommitCall) Return(arg0 git.CommitInfo, arg1 error) *MockRepoFindFileLastCommitCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepoFindFileLastCommitCall) Do(f func(string) (git.CommitInfo, error)) *MockRepoFindFileLastCommitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepoFindFileLastCommitCall) DoAndReturn(f func(string) (git.CommitInfo, error)) *MockRepoFindFileLastCommitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FindMergePoints mocks base method.
func (m *MockRepo) FindMergePoints(commitId string) ([]git.CommitInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindMergePoints", commitId)
	ret0, _ := ret[0].([]git.CommitInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindMergePoints indicates an expected call of FindMergePoints.
func (mr *MockRepoMockRecorder) FindMergePoints(commitId any) *MockRepoFindMergePointsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindMergePoints", reflect.TypeOf((*MockRepo)(nil).FindMergePoints), commitId)
	return &MockRepoFindMergePointsCall{Call: call}
}

// MockRepoFindMergePointsCall wrap *gomock.Call
type MockRepoFindMergePointsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepoFindMergePointsCall) Return(arg0 []git.CommitInfo, arg1 error) *MockRepoFindMergePointsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepoFindMergePointsCall) Do(f func(string) ([]git.CommitInfo, error)) *MockRepoFindMergePointsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepoFindMergePointsCall) DoAndReturn(f func(string) ([]git.CommitInfo, error)) *MockRepoFindMergePointsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FreshCommits mocks base method.
func (m *MockRepo) FreshCommits() ([]git.CommitInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FreshCommits")
	ret0, _ := ret[0].([]git.CommitInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FreshCommits indicates an expected call of FreshCommits.
func (mr *MockRepoMockRecorder) FreshCommits() *MockRepoFreshCommitsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FreshCommits", reflect.TypeOf((*MockRepo)(nil).FreshCommits))
	return &MockRepoFreshCommitsCall{Call: call}
}

// MockRepoFreshCommitsCall wrap *gomock.Call
type MockRepoFreshCommitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepoFreshCommitsCall) Return(arg0 []git.CommitInfo, arg1 error) *MockRepoFreshCommitsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepoFreshCommitsCall) Do(f func() ([]git.CommitInfo, error)) *MockRepoFreshCommitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepoFreshCommitsCall) DoAndReturn(f func() ([]git.CommitInfo, error)) *MockRepoFreshCommitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListFiles mocks base method.
func (m *MockRepo) ListFiles(path string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListFiles", path)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListFiles indicates an expected call of ListFiles.
func (mr *MockRepoMockRecorder) ListFiles(path any) *MockRepoListFilesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListFiles", reflect.TypeOf((*MockRepo)(nil).ListFiles), path)
	return &MockRepoListFilesCall{Call: call}
}

// MockRepoListFilesCall wrap *gomock.Call
type MockRepoListFilesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepoListFilesCall) Return(arg0 []string, arg1 error) *MockRepoListFilesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepoListFilesCall) Do(f func(string) ([]string, error)) *MockRepoListFilesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepoListFilesCall) DoAndReturn(f func(string) ([]string, error)) *MockRepoListFilesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Pull mocks base method.
func (m *MockRepo) Pull() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Pull")
	ret0, _ := ret[0].(error)
	return ret0
}

// Pull indicates an expected call of Pull.
func (mr *MockRepoMockRecorder) Pull() *MockRepoPullCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pull", reflect.TypeOf((*MockRepo)(nil).Pull))
	return &MockRepoPullCall{Call: call}
}

// MockRepoPullCall wrap *gomock.Call
type MockRepoPullCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepoPullCall) Return(arg0 error) *MockRepoPullCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepoPullCall) Do(f func() error) *MockRepoPullCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepoPullCall) DoAndReturn(f func() error) *MockRepoPullCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockCommandRunner is a mock of CommandRunner interface.
type MockCommandRunner struct {
	ctrl     *gomock.Controller
	recorder *MockCommandRunnerMockRecorder
	isgomock struct{}
}

// MockCommandRunnerMockRecorder is the mock recorder for MockCommandRunner.
type MockCommandRunnerMockRecorder struct {
	mock *MockCommandRunner
}

// NewMockCommandRunner creates a new mock instance.
func NewMockCommandRunner(ctrl *gomock.Controller) *MockCommandRunner {
	mock := &MockCommandRunner{ctrl: ctrl}
	mock.recorder = &MockCommandRunnerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommandRunner) EXPECT() *MockCommandRunnerMockRecorder {
	return m.recorder
}

// Exec mocks base method.
func (m *MockCommandRunner) Exec(workingDir, cmd string, args ...string) (string, error) {
	m.ctrl.T.Helper()
	varargs := []any{workingDir, cmd}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockCommandRunnerMockRecorder) Exec(workingDir, cmd any, args ...any) *MockCommandRunnerExecCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{workingDir, cmd}, args...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockCommandRunner)(nil).Exec), varargs...)
	return &MockCommandRunnerExecCall{Call: call}
}

// MockCommandRunnerExecCall wrap *gomock.Call
type MockCommandRunnerExecCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockCommandRunnerExecCall) Return(arg0 string, arg1 error) *MockCommandRunnerExecCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockCommandRunnerExecCall) Do(f func(string, string, ...string) (string, error)) *MockCommandRunnerExecCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockCommandRunnerExecCall) DoAndReturn(f func(string, string, ...string) (string, error)) *MockCommandRunnerExecCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
